<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D ãƒ—ãƒ©ãƒã‚¿ãƒªã‚®ãƒ¤ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ - ç‰©ç†æ­£ç¢ºç‰ˆ</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      font-family:'Segoe UI',system-ui,-apple-system,Roboto,Arial,sans-serif;
      background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);
      color:#fff; overflow:hidden;
    }
    #canvas-container{width:100vw;height:100vh;position:relative}
    .ui{position:absolute;inset:0;pointer-events:none}
    .panel{
      position:absolute;top:20px;left:20px;width:380px;max-height:calc(100vh - 40px);
      overflow-y:auto;pointer-events:auto;background:rgba(0,0,0,.85);
      backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.15);
      border-radius:16px;padding:18px;box-shadow:0 12px 36px rgba(0,0,0,.5);
    }
    .title{font-weight:900;font-size:18px;margin-bottom:6px;color:#ffd700}
    .sub{opacity:.85;font-size:13px;line-height:1.4;margin-bottom:14px}
    .group{
      border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:14px;margin-bottom:12px;
      background:rgba(255,255,255,.05);
    }
    .group h3{font-size:14px;color:#4af2a1;margin-bottom:10px;font-weight:800}
    label{display:flex;justify-content:space-between;align-items:center;gap:12px;font-size:13px;margin-bottom:8px}
    .val{color:#ffd700;font-weight:900;min-width:80px;text-align:right}
    input[type="range"]{width:100%;height:6px;border-radius:3px;background:rgba(255,255,255,.25);outline:none;-webkit-appearance:none}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#ffd700;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.4)}
    input[type="range"]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#ffd700;cursor:pointer;border:none;box-shadow:0 2px 6px rgba(0,0,0,.4)}
    .checks{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
    .chk{display:flex;align-items:center;gap:6px;font-size:12px}
    .chk input{width:16px;height:16px;cursor:pointer}
    .presets{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .preset{
      text-align:center;background:rgba(255,255,255,.15);
      border:1px solid rgba(255,255,255,.2);
      border-radius:10px;padding:12px 8px;font-weight:800;font-size:12px;
      cursor:pointer;color:#fff;transition:.2s;
    }
    .preset:hover{background:rgba(255,255,255,.25);transform:translateY(-2px)}
    .btns{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    button{
      border:none;border-radius:10px;padding:12px;font-weight:900;font-size:13px;cursor:pointer;color:#fff;
      box-shadow:0 6px 16px rgba(0,0,0,.3);transition:.2s;
    }
    button:hover{transform:translateY(-2px);filter:brightness(1.1)}
    .b1{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%)}
    .b2{background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%)}
    .right{
      position:absolute;top:20px;right:20px;width:340px;pointer-events:auto;
      background:rgba(0,0,0,.85);backdrop-filter:blur(12px);
      border:1px solid rgba(255,255,255,.15);
      border-radius:16px;padding:18px;box-shadow:0 12px 36px rgba(0,0,0,.5);
    }
    .badge{
      display:inline-block;padding:8px 14px;border-radius:999px;font-size:13px;font-weight:900;margin-bottom:12px;
      background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%);
    }
    .card{
      border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:12px;margin-bottom:10px;background:rgba(255,255,255,.05);
    }
    .k{font-size:12px;opacity:.8;margin-bottom:4px}
    .v{font-size:20px;font-weight:900;color:#ffd700}
    .formula{
      background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.3);
      border-radius:8px;padding:10px;margin-top:10px;font-size:12px;
      font-family:'Courier New',monospace;color:#ffd700;
    }
    @media (max-width: 1200px) {
      .panel{width:320px}
      .right{width:280px}
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui">
    <div class="panel">
      <div class="title">âš™ï¸ 3D ãƒ—ãƒ©ãƒã‚¿ãƒªã‚®ãƒ¤ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</div>
      <div class="sub">ã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆæ­¯å½¢ / Williså¼é‹å‹•å­¦ / å®Œå…¨å™›ã¿åˆã„ä¿è¨¼</div>

```
  <div class="group">
    <h3>ğŸ“ ã‚®ãƒ¤ä»•æ§˜</h3>
    <div style="font-size:12px;opacity:.9;line-height:1.6">
      â€¢ ã‚µãƒ³æ­¯æ•°: <strong style="color:#ffd700">Zs = 20</strong><br>
      â€¢ ãƒ—ãƒ©ãƒãƒƒãƒˆæ­¯æ•°: <strong style="color:#ffd700">Zp = 20</strong><br>
      â€¢ ãƒªãƒ³ã‚°æ­¯æ•°: <strong style="color:#ffd700">Zr = 60</strong><br>
      â€¢ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«: <strong style="color:#ffd700">m = 0.10</strong><br>
      â€¢ åœ§åŠ›è§’: <strong style="color:#ffd700">Î± = 20Â°</strong>
    </div>
    <div class="formula">
      Williså¼: (Ï‰sÂ·Zs + Ï‰rÂ·Zr) = Ï‰cÂ·(Zs + Zr)
    </div>
  </div>

  <div class="group">
    <h3>ğŸ® å‹•ä½œãƒ¢ãƒ¼ãƒ‰</h3>
    <div class="presets">
      <button class="preset" onclick="setMode('reduction')">æ¸›é€Ÿ<br>(Sunå…¥åŠ›)</button>
      <button class="preset" onclick="setMode('increase')">å¢—é€Ÿ<br>(Ringå…¥åŠ›)</button>
      <button class="preset" onclick="setMode('direct')">ç›´çµ<br>(åŒé€Ÿ)</button>
      <button class="preset" onclick="setMode('reverse')">é€†è»¢<br>(Carå…¥åŠ›)</button>
    </div>
  </div>

  <div class="group">
    <h3>ğŸšï¸ é€Ÿåº¦åˆ¶å¾¡ï¼ˆRPMï¼‰</h3>

    <div style="margin:12px 0">
      <label>ã‚µãƒ³ã‚®ãƒ¤ <span class="val" id="sunTxt">60.0</span></label>
      <input id="sunSlider" type="range" min="-200" max="200" step="0.1" value="60">
      <div class="checks"><div class="chk"><input id="sunLock" type="checkbox">å›ºå®š</div></div>
    </div>

    <div style="margin:12px 0">
      <label>ãƒªãƒ³ã‚°ã‚®ãƒ¤ <span class="val" id="ringTxt">0.0</span></label>
      <input id="ringSlider" type="range" min="-200" max="200" step="0.1" value="0">
      <div class="checks"><div class="chk"><input id="ringLock" type="checkbox" checked>å›ºå®š</div></div>
    </div>

    <div style="margin:12px 0">
      <label>ã‚­ãƒ£ãƒªã‚¢ <span class="val" id="carTxt">0.0</span></label>
      <input id="carSlider" type="range" min="-200" max="200" step="0.1" value="0">
      <div class="checks"><div class="chk"><input id="carLock" type="checkbox">å›ºå®š</div></div>
    </div>
  </div>

  <div class="group">
    <h3>ğŸ¨ è¡¨ç¤ºè¨­å®š</h3>
    <div class="checks">
      <div class="chk"><input id="showCarrier" type="checkbox" checked>ã‚­ãƒ£ãƒªã‚¢</div>
      <div class="chk"><input id="showAxes" type="checkbox" checked>è»¸</div>
      <div class="chk"><input id="showWireframe" type="checkbox">ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </div>
      <div class="chk"><input id="autoRotate" type="checkbox">è‡ªå‹•å›è»¢</div>
    </div>

    <div style="margin:12px 0">
      <label>ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼å¼·åº¦ <span class="val" id="blurTxt">0%</span></label>
      <input id="blurSlider" type="range" min="0" max="70" step="5" value="0">
    </div>

    <div class="btns">
      <button class="b1" onclick="toggleAnim()" id="toggleBtn">â¸ï¸ åœæ­¢</button>
      <button class="b2" onclick="resetView()">ğŸ“· è¦–ç‚¹ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </div>
</div>

<div class="right">
  <div class="badge" id="modeBadge">æ¸›é€Ÿãƒ¢ãƒ¼ãƒ‰</div>
  
  <div class="card"><div class="k">ã‚µãƒ³ã‚®ãƒ¤å›è»¢æ•°</div><div class="v" id="statSun">60.0 RPM</div></div>
  <div class="card"><div class="k">ãƒ—ãƒ©ãƒãƒƒãƒˆè‡ªè»¢ï¼ˆå¯¾ã‚­ãƒ£ãƒªã‚¢ï¼‰</div><div class="v" id="statPlanet">0.0 RPM</div></div>
  <div class="card"><div class="k">ãƒªãƒ³ã‚°ã‚®ãƒ¤å›è»¢æ•°</div><div class="v" id="statRing">0.0 RPM</div></div>
  <div class="card"><div class="k">ã‚­ãƒ£ãƒªã‚¢å›è»¢æ•°</div><div class="v" id="statCar">15.0 RPM</div></div>
  <div class="card"><div class="k">æ¸›é€Ÿæ¯”ï¼ˆå…¥åŠ›/å‡ºåŠ›ï¼‰</div><div class="v" id="statRatio">4.00:1</div></div>
  <div class="card"><div class="k">ãƒˆãƒ«ã‚¯å¢—å¹…ç‡</div><div class="v" id="statTorque">4.00x</div></div>
  
  <div class="formula" style="margin-top:14px">
    æ¤œè¨¼: Ï‰sÂ·20 + Ï‰rÂ·60 = Ï‰cÂ·80<br>
    <span id="willisCheck" style="color:#4af2a1">âœ“ æˆç«‹</span>
  </div>
</div>
```

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ï¼šãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼ãƒ»æ®‹åƒåŠ¹æœç”¨ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

  <script>
    // ============================================================
    // ã‚®ãƒ¤ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆç‰©ç†çš„ã«æ­£ç¢ºï¼‰
    // ============================================================
    const Zs = 20;  // ã‚µãƒ³æ­¯æ•°
    const Zp = 20;  // ãƒ—ãƒ©ãƒãƒƒãƒˆæ­¯æ•°
    const Zr = 60;  // ãƒªãƒ³ã‚°æ­¯æ•°ï¼ˆ= Zs + 2Â·Zpï¼‰

    const module = 0.10;  // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    const pressureAngle = 20 * Math.PI / 180;  // åœ§åŠ›è§’ï¼ˆradï¼‰
    
    // ãƒ”ãƒƒãƒå††åŠå¾„ï¼ˆç‰©ç†çš„ã«æ­£ç¢ºï¼‰
    const rSun = (module * Zs) / 2;      // 1.0
    const rPlanet = (module * Zp) / 2;   // 1.0
    const rRing = (module * Zr) / 2;     // 3.0
    
    // ä¸­å¿ƒé–“è·é›¢ï¼ˆå®Œå…¨å™›ã¿åˆã„æ¡ä»¶ï¼‰
    const centerDistance = rSun + rPlanet;  // 2.0
    
    // æ­¯ä¸ˆä¿‚æ•°ï¼ˆJISæ¨™æº–ï¼‰
    const addendum = 1.00 * module;      // æ­¯å…ˆé«˜ã•
    const dedendum = 1.25 * module;      // æ­¯åº•é«˜ã•
    
    const gearThickness = 0.35;
    const numPlanets = 3;

    // ============================================================
    // çŠ¶æ…‹å¤‰æ•°
    // ============================================================
    let sunSpeed = 60;    // RPM
    let ringSpeed = 0;    // RPM
    let carrierSpeed = 0; // RPM

    let sunLocked = false;
    let ringLocked = true;
    let carrierLocked = false;

    let sunAngle = 0;
    let ringAngle = 0;
    let carrierAngle = 0;

    let running = true;
    let lastChanged = "sun";
    let lastTime = 0; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ç®¡ç†ç”¨ï¼ˆåˆå›ã«è¨­å®šï¼‰
    let isFirstFrame = true; // åˆå›ãƒ•ãƒ¬ãƒ¼ãƒ æ¤œå‡ºç”¨

    // ============================================================
    // Three.js ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    // ============================================================
    let scene, camera, renderer, controls, axesHelper;
    let composer, afterimagePass; // ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ç”¨
    let sunMesh, ringMesh, carrierGroup;
    let planetMeshes = [];
    let carrierArms = [];
    let wireframeObjects = [];

    // ============================================================
    // ã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆæ­¯å½¢ç”Ÿæˆï¼ˆç‰©ç†çš„ã«æ­£ç¢ºï¼‰
    // ============================================================
    function involutePoint(baseRadius, t) {
      return new THREE.Vector2(
        baseRadius * (Math.cos(t) + t * Math.sin(t)),
        baseRadius * (Math.sin(t) - t * Math.cos(t))
      );
    }

    function tFromRadius(baseRadius, radius) {
      const ratio = radius / baseRadius;
      return Math.sqrt(Math.max(0, ratio * ratio - 1));
    }

    function buildInvoluteGearProfile(pitchRadius, numTeeth, isInternal = false) {
      const baseRadius = pitchRadius * Math.cos(pressureAngle);
      const outerRadius = pitchRadius + addendum;
      const rootRadius = Math.max(baseRadius * 0.5, pitchRadius - dedendum);
      
      const angularPitch = 2 * Math.PI / numTeeth;
      const toothThickness = Math.PI * module / 2;  // ãƒ”ãƒƒãƒå††ä¸Šã®æ­¯åš
      
      const shape = new THREE.Shape();
      
      if (isInternal) {
        // å†…æ­¯è»Šï¼ˆãƒªãƒ³ã‚°ã‚®ãƒ¤ï¼‰
        const innerRadius = pitchRadius - addendum;
        const valleyRadius = pitchRadius + dedendum;
        
        // å¤–å‘¨å††ï¼ˆé«˜å“è³ªåŒ–ï¼šã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ã‚’å¢—åŠ ï¼‰
        for (let i = 0; i <= 128; i++) {
          const angle = (i / 128) * 2 * Math.PI;
          const x = Math.cos(angle) * valleyRadius;
          const y = Math.sin(angle) * valleyRadius;
          if (i === 0) shape.moveTo(x, y);
          else shape.lineTo(x, y);
        }
        
        // å†…å´ã®æ­¯ï¼ˆãƒ›ãƒ¼ãƒ«ï¼‰
        const hole = new THREE.Path();
        const startAngle = 0;
        hole.moveTo(Math.cos(startAngle) * innerRadius, Math.sin(startAngle) * innerRadius);
        
        for (let i = 0; i < numTeeth; i++) {
          const baseAngle = i * angularPitch;
          
          // æ­¯åº•å††å¼§
          const dedAng1 = baseAngle - angularPitch * 0.45;
          const dedAng2 = baseAngle - angularPitch * 0.20;
          for (let j = 0; j <= 6; j++) {
            const a = dedAng1 + (dedAng2 - dedAng1) * (j / 6);
            hole.lineTo(Math.cos(a) * pitchRadius, Math.sin(a) * pitchRadius);
          }
          
          // å·¦ãƒ•ãƒ©ãƒ³ã‚¯ï¼ˆé«˜å“è³ªã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆï¼šã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢—åŠ ï¼‰
          const t0 = tFromRadius(baseRadius, Math.max(baseRadius, innerRadius));
          const t1 = tFromRadius(baseRadius, pitchRadius);
          for (let j = 0; j <= 12; j++) {
            const t = t0 + (t1 - t0) * (j / 12);
            const p = involutePoint(baseRadius, t);
            const angle = Math.atan2(p.y, p.x) + baseAngle - angularPitch * 0.20;
            hole.lineTo(Math.cos(angle) * p.length(), Math.sin(angle) * p.length());
          }
          
          // æ­¯å…ˆå††å¼§
          const tipAng1 = baseAngle - angularPitch * 0.05;
          const tipAng2 = baseAngle + angularPitch * 0.05;
          for (let j = 0; j <= 6; j++) {
            const a = tipAng1 + (tipAng2 - tipAng1) * (j / 6);
            hole.lineTo(Math.cos(a) * innerRadius, Math.sin(a) * innerRadius);
          }
          
          // å³ãƒ•ãƒ©ãƒ³ã‚¯ï¼ˆé«˜å“è³ªã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆï¼šã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢—åŠ ï¼‰
          for (let j = 12; j >= 0; j--) {
            const t = t0 + (t1 - t0) * (j / 12);
            const p = involutePoint(baseRadius, t);
            const angle = Math.atan2(p.y, p.x) + baseAngle + angularPitch * 0.20;
            hole.lineTo(Math.cos(angle) * p.length(), Math.sin(angle) * p.length());
          }
          
          // æ¬¡ã®æ­¯åº•ã¸
          const dedAng3 = baseAngle + angularPitch * 0.20;
          const dedAng4 = baseAngle + angularPitch * 0.55;
          for (let j = 0; j <= 6; j++) {
            const a = dedAng3 + (dedAng4 - dedAng3) * (j / 6);
            hole.lineTo(Math.cos(a) * pitchRadius, Math.sin(a) * pitchRadius);
          }
        }
        
        shape.holes.push(hole);
        
      } else {
        // å¤–æ­¯è»Šï¼ˆã‚µãƒ³ã‚®ãƒ¤ã€ãƒ—ãƒ©ãƒãƒƒãƒˆã‚®ãƒ¤ï¼‰
        let firstPoint = null;
        
        for (let i = 0; i < numTeeth; i++) {
          const baseAngle = i * angularPitch;
          
          // æ­¯åº•ã®é–‹å§‹ç‚¹
          const rootAng1 = baseAngle - angularPitch * 0.55;
          const rootStart = new THREE.Vector2(
            Math.cos(rootAng1) * rootRadius,
            Math.sin(rootAng1) * rootRadius
          );
          
          if (i === 0) {
            shape.moveTo(rootStart.x, rootStart.y);
            firstPoint = rootStart;
          } else {
            shape.lineTo(rootStart.x, rootStart.y);
          }
          
          // æ­¯åº•å††å¼§
          const rootAng2 = baseAngle - angularPitch * 0.25;
          for (let j = 1; j <= 6; j++) {
            const a = rootAng1 + (rootAng2 - rootAng1) * (j / 6);
            shape.lineTo(Math.cos(a) * rootRadius, Math.sin(a) * rootRadius);
          }
          
          // å·¦ãƒ•ãƒ©ãƒ³ã‚¯ï¼ˆã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆæ›²ç·šï¼‰
          const tStart = tFromRadius(baseRadius, Math.max(baseRadius, rootRadius));
          const tEnd = tFromRadius(baseRadius, outerRadius);
          
          for (let j = 0; j <= 10; j++) {
            const t = tStart + (tEnd - tStart) * (j / 10);
            const p = involutePoint(baseRadius, t);
            const offsetAngle = baseAngle - toothThickness / (2 * pitchRadius);
            const angle = Math.atan2(p.y, p.x) + offsetAngle;
            const r = p.length();
            shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
          }
          
          // æ­¯å…ˆå††å¼§
          const tipAngLeft = Math.atan2(
            involutePoint(baseRadius, tEnd).y,
            involutePoint(baseRadius, tEnd).x
          ) + baseAngle - toothThickness / (2 * pitchRadius);
          
          const tipAngRight = baseAngle + toothThickness / (2 * pitchRadius) - 
                              Math.atan2(
                                involutePoint(baseRadius, tEnd).y,
                                involutePoint(baseRadius, tEnd).x
                              );
          
          for (let j = 1; j <= 8; j++) {
            const a = tipAngLeft + (tipAngRight - tipAngLeft) * (j / 8);
            shape.lineTo(Math.cos(a) * outerRadius, Math.sin(a) * outerRadius);
          }
          
          // å³ãƒ•ãƒ©ãƒ³ã‚¯ï¼ˆã‚¤ãƒ³ãƒœãƒªãƒ¥ãƒ¼ãƒˆæ›²ç·šãƒ»é€†é †ï¼‰
          for (let j = 10; j >= 0; j--) {
            const t = tStart + (tEnd - tStart) * (j / 10);
            const p = involutePoint(baseRadius, t);
            const offsetAngle = baseAngle + toothThickness / (2 * pitchRadius);
            const angle = Math.atan2(p.y, p.x) + offsetAngle;
            const r = p.length();
            shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
          }
          
          // æ¬¡ã®æ­¯åº•ã¸
          const rootAng3 = baseAngle + angularPitch * 0.25;
          const rootAng4 = baseAngle + angularPitch * 0.55;
          for (let j = 1; j <= 6; j++) {
            const a = rootAng3 + (rootAng4 - rootAng3) * (j / 6);
            shape.lineTo(Math.cos(a) * rootRadius, Math.sin(a) * rootRadius);
          }
        }
        
        if (firstPoint) {
          shape.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      
      return shape;
    }

    function extrudeGear(shape) {
      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: gearThickness,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.02,
        bevelSegments: 5,      // é«˜å“è³ªãƒ™ãƒ™ãƒ«
        curveSegments: 24      // ã‚«ãƒ¼ãƒ–ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢—åŠ 
      });
      geometry.rotateX(Math.PI / 2);
      geometry.center();
      geometry.computeVertexNormals();
      geometry.normalizeNormals();
      return geometry;
    }

    // ============================================================
    // ã‚·ãƒ¼ãƒ³åˆæœŸåŒ–
    // ============================================================
    function initScene() {
      const container = document.getElementById("canvas-container");
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      scene.fog = new THREE.Fog(0x0a0a1a, 15, 60);
      
      camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 200);
      camera.position.set(6, 4, 8);
      
      // é«˜å“è³ªãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
        stencil: false
      });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio); // ãƒ•ãƒ«ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      container.appendChild(renderer.domElement);
      
      // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(8, 12, 8);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(4096, 4096); // é«˜è§£åƒåº¦ã‚·ãƒ£ãƒ‰ã‚¦ãƒãƒƒãƒ—
      keyLight.shadow.camera.near = 0.5;
      keyLight.shadow.camera.far = 50;
      keyLight.shadow.camera.left = -10;
      keyLight.shadow.camera.right = 10;
      keyLight.shadow.camera.top = 10;
      keyLight.shadow.camera.bottom = -10;
      keyLight.shadow.bias = -0.0001; // ã‚·ãƒ£ãƒ‰ã‚¦ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆè»½æ¸›
      keyLight.shadow.radius = 2; // ã‚½ãƒ•ãƒˆã‚·ãƒ£ãƒ‰ã‚¦
      scene.add(keyLight);
      
      const fillLight = new THREE.DirectionalLight(0x66aaff, 0.4);
      fillLight.position.set(-6, 6, -6);
      scene.add(fillLight);
      
      const rimLight = new THREE.PointLight(0xffd700, 0.9, 35);
      rimLight.position.set(0, 8, 0);
      scene.add(rimLight);

      // ãƒªãƒ³ã‚°ã‚®ãƒ¤å°‚ç”¨ã‚¢ã‚¯ã‚»ãƒ³ãƒˆãƒ©ã‚¤ãƒˆï¼ˆå›è»¢ã‚’è¦–è¦šåŒ–ï¼‰
      const ringAccentLight = new THREE.SpotLight(0xffffff, 0.8);
      ringAccentLight.position.set(4, 2, 0);
      ringAccentLight.angle = Math.PI / 4;
      ringAccentLight.penumbra = 0.3;
      ringAccentLight.decay = 2;
      ringAccentLight.distance = 12;
      scene.add(ringAccentLight);

      // ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ï¼šã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆOFFï¼‰
      composer = new THREE.EffectComposer(renderer);

      // é€šå¸¸ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¹
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);

      // æ®‹åƒåŠ¹æœï¼ˆãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼ï¼‰- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç„¡åŠ¹
      afterimagePass = new THREE.AfterimagePass(0.0); // 0.0 = ã‚ªãƒ•
      composer.addPass(afterimagePass);

      // æœ€çµ‚å‡ºåŠ›ãƒ‘ã‚¹
      const copyPass = new THREE.ShaderPass(THREE.CopyShader);
      copyPass.renderToScreen = true;
      composer.addPass(copyPass);

      // ã‚°ãƒªãƒƒãƒ‰
      const grid = new THREE.GridHelper(24, 24, 0x444444, 0x222222);
      grid.position.y = -2.5;
      scene.add(grid);
      
      // è»¸ãƒ˜ãƒ«ãƒ‘ãƒ¼
      axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);
      
      // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 25;
      
      buildGears();
      
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        composer.setSize(innerWidth, innerHeight); // ã‚³ãƒ³ãƒãƒ¼ã‚¶ãƒ¼ã‚‚ãƒªã‚µã‚¤ã‚º
      });
    }

    // ============================================================
    // ã‚®ãƒ¤ãƒ¡ãƒƒã‚·ãƒ¥æ§‹ç¯‰
    // ============================================================
    function buildGears() {
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      if (sunMesh) scene.remove(sunMesh);
      if (ringMesh) scene.remove(ringMesh);
      if (carrierGroup) scene.remove(carrierGroup);
      planetMeshes = [];
      carrierArms = [];
      wireframeObjects = [];
      
      // ã‚µãƒ³ã‚®ãƒ¤
      const sunShape = buildInvoluteGearProfile(rSun, Zs, false);
      const sunGeo = extrudeGear(sunShape);
      sunMesh = new THREE.Mesh(
        sunGeo,
        new THREE.MeshStandardMaterial({
          color: 0xff6b6b,
          metalness: 0.4,
          roughness: 0.3
        })
      );
      sunMesh.castShadow = true;
      sunMesh.receiveShadow = true;
      scene.add(sunMesh);
      
      // ã‚µãƒ³ã‚®ãƒ¤ã®ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
      const sunWire = new THREE.LineSegments(
        new THREE.EdgesGeometry(sunGeo),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
      );
      sunMesh.add(sunWire);
      wireframeObjects.push(sunWire);
      
      // ãƒªãƒ³ã‚°ã‚®ãƒ¤ï¼ˆå…ƒã®è¨­å®šã«æˆ»ã™ï¼‰
      const ringShape = buildInvoluteGearProfile(rRing, Zr, true);
      const ringGeo = extrudeGear(ringShape);

      // ãƒªãƒ³ã‚°ã‚®ãƒ¤ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªå“è³ªå‘ä¸Š
      ringGeo.computeVertexNormals();
      ringGeo.normalizeNormals();

      ringMesh = new THREE.Mesh(
        ringGeo,
        new THREE.MeshStandardMaterial({
          color: 0x8b4789,         // å…ƒã®ç´«è‰²
          metalness: 0.35,         // å…ƒã®ãƒ¡ã‚¿ãƒ«ãƒã‚¹
          roughness: 0.35,         // å…ƒã®ç²—ã•
          side: THREE.DoubleSide,
          flatShading: false       // ã‚¹ãƒ ãƒ¼ã‚ºã‚·ã‚§ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
        })
      );
      ringMesh.castShadow = true;
      ringMesh.receiveShadow = true;
      scene.add(ringMesh);

      const ringWire = new THREE.LineSegments(
        new THREE.EdgesGeometry(ringGeo, 15), // ã‚¨ãƒƒã‚¸æ¤œå‡ºã®é–¾å€¤ã‚’èª¿æ•´
        new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.4,            // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è‹¥å¹²æ˜ã‚‹ã
          linewidth: 1
        })
      );
      ringMesh.add(ringWire);
      wireframeObjects.push(ringWire);

      // ãƒªãƒ³ã‚°ã‚®ãƒ¤ã®å›è»¢ã‚’è¦–è¦šåŒ–ã™ã‚‹ãƒãƒ¼ã‚«ãƒ¼ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ãƒ»éè¡¨ç¤ºï¼‰
      const markerGeo = new THREE.BoxGeometry(0.3, gearThickness * 1.2, 0.3);
      const markerMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      });
      const marker = new THREE.Mesh(markerGeo, markerMat);
      marker.position.set(rRing, 0, 0);
      marker.visible = false; // ãƒ‡ãƒãƒƒã‚°å®Œäº†ã®ãŸã‚éè¡¨ç¤º
      ringMesh.add(marker);
      
      // ã‚­ãƒ£ãƒªã‚¢ã¨ãƒ—ãƒ©ãƒãƒƒãƒˆã‚®ãƒ¤
      carrierGroup = new THREE.Group();
      scene.add(carrierGroup);
      
      const planetShape = buildInvoluteGearProfile(rPlanet, Zp, false);
      const planetGeo = extrudeGear(planetShape);
      
      for (let i = 0; i < numPlanets; i++) {
        const angle = (i / numPlanets) * 2 * Math.PI;
        
        // ãƒ—ãƒ©ãƒãƒƒãƒˆã‚®ãƒ¤
        const planet = new THREE.Mesh(
          planetGeo,
          new THREE.MeshStandardMaterial({
            color: 0x4a9eff,
            metalness: 0.4,
            roughness: 0.3
          })
        );
        planet.position.set(
          Math.cos(angle) * centerDistance,
          0,
          Math.sin(angle) * centerDistance
        );
        planet.castShadow = true;
        planet.receiveShadow = true;
        carrierGroup.add(planet);
        planetMeshes.push(planet);
        
        const planetWire = new THREE.LineSegments(
          new THREE.EdgesGeometry(planetGeo),
          new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
        );
        planet.add(planetWire);
        wireframeObjects.push(planetWire);
        
        // ã‚­ãƒ£ãƒªã‚¢ã‚¢ãƒ¼ãƒ 
        const armGeo = new THREE.BoxGeometry(centerDistance * 2.2, 0.10, 0.15);
        const arm = new THREE.Mesh(
          armGeo,
          new THREE.MeshStandardMaterial({
            color: 0x4af2a1,
            metalness: 0.2,
            roughness: 0.4,
            transparent: true,
            opacity: 0.9
          })
        );
        arm.rotation.y = angle;
        arm.castShadow = true;
        carrierGroup.add(arm);
        carrierArms.push(arm);
      }
      
      // ã‚­ãƒ£ãƒªã‚¢ä¸­å¿ƒãƒãƒ–
      const hub = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.25, gearThickness * 1.2, 24),
        new THREE.MeshStandardMaterial({
          color: 0x4af2a1,
          metalness: 0.3,
          roughness: 0.4
        })
      );
      hub.rotation.x = Math.PI / 2;
      hub.castShadow = true;
      carrierGroup.add(hub);
      carrierArms.push(hub);
    }

    // ============================================================
    // Williså¼ã«ã‚ˆã‚‹é‹å‹•å­¦è¨ˆç®—
    // ============================================================
    function solveKinematics() {
      // Williså¼: Ï‰sÂ·Zs + Ï‰rÂ·Zr = Ï‰cÂ·(Zs + Zr)
      // ç†è«–å€¤:
      // - æ¸›é€Ÿ: Ï‰r=0, Ï‰s=60 â†’ Ï‰c=15
      // - å¢—é€Ÿ: Ï‰s=0, Ï‰r=60 â†’ Ï‰c=45
      // - ç›´çµ: Ï‰s=Ï‰r=Ï‰c=60
      // - é€†è»¢: Ï‰s=0, Ï‰c=60 â†’ Ï‰r=80

      const lockCount = (sunLocked ? 1 : 0) + (ringLocked ? 1 : 0) + (carrierLocked ? 1 : 0);

      if (lockCount >= 2) {
        // 2ã¤ä»¥ä¸Šå›ºå®š â†’ ã™ã¹ã¦åœæ­¢
        if (!sunLocked) sunSpeed = 0;
        if (!ringLocked) ringSpeed = 0;
        if (!carrierLocked) carrierSpeed = 0;
        return;
      }

      if (lockCount === 1) {
        if (ringLocked) {
          // ãƒªãƒ³ã‚°å›ºå®šï¼ˆæ¸›é€Ÿãƒ¢ãƒ¼ãƒ‰ï¼‰
          // Williså¼: Ï‰sÂ·Zs + 0Â·Zr = Ï‰cÂ·(Zs + Zr)
          // â†’ Ï‰c = (Ï‰sÂ·Zs) / (Zs + Zr)
          ringSpeed = 0;
          if (lastChanged === "sun") {
            carrierSpeed = (sunSpeed * Zs) / (Zs + Zr);
          } else {
            sunSpeed = (carrierSpeed * (Zs + Zr)) / Zs;
          }
        } else if (sunLocked) {
          // ã‚µãƒ³å›ºå®šï¼ˆå¢—é€Ÿãƒ¢ãƒ¼ãƒ‰ï¼‰
          // Williså¼: 0Â·Zs + Ï‰rÂ·Zr = Ï‰cÂ·(Zs + Zr)
          // â†’ Ï‰c = (Ï‰rÂ·Zr) / (Zs + Zr)
          sunSpeed = 0;
          if (lastChanged === "ring") {
            carrierSpeed = (ringSpeed * Zr) / (Zs + Zr);
          } else {
            // ã‚­ãƒ£ãƒªã‚¢ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
            ringSpeed = (carrierSpeed * (Zs + Zr)) / Zr;
          }
        } else if (carrierLocked) {
          // ã‚­ãƒ£ãƒªã‚¢å›ºå®šï¼ˆæ–¹å‘è»¢æ›ãƒ¢ãƒ¼ãƒ‰ï¼‰
          // Williså¼: Ï‰sÂ·Zs + Ï‰rÂ·Zr = 0
          // â†’ Ï‰r = -(Ï‰sÂ·Zs) / Zr
          carrierSpeed = 0;
          if (lastChanged === "sun") {
            ringSpeed = -(sunSpeed * Zs) / Zr;
          } else {
            sunSpeed = -(ringSpeed * Zr) / Zs;
          }
        }
      } else {
        // ãƒ­ãƒƒã‚¯ãªã—ï¼ˆç›´çµãƒ¢ãƒ¼ãƒ‰ãªã©ï¼‰
        // Williså¼: Ï‰sÂ·Zs + Ï‰rÂ·Zr = Ï‰cÂ·(Zs + Zr) ã‚’æº€ãŸã™ã‚ˆã†ã«è¨ˆç®—
        if (lastChanged === "sun") {
          // ã‚µãƒ³ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
          if (Math.abs(ringSpeed) > 0.01) {
            // ãƒªãƒ³ã‚°ãŒè¨­å®šæ¸ˆã¿ â†’ ã‚­ãƒ£ãƒªã‚¢ã‚’è¨ˆç®—
            carrierSpeed = (sunSpeed * Zs + ringSpeed * Zr) / (Zs + Zr);
          } else {
            // ãƒªãƒ³ã‚°ãŒæœªè¨­å®š â†’ ã‚­ãƒ£ãƒªã‚¢ã‹ã‚‰é€†ç®—
            ringSpeed = (carrierSpeed * (Zs + Zr) - sunSpeed * Zs) / Zr;
          }
        } else if (lastChanged === "ring") {
          // ãƒªãƒ³ã‚°ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
          if (Math.abs(sunSpeed) > 0.01) {
            // ã‚µãƒ³ãŒè¨­å®šæ¸ˆã¿ â†’ ã‚­ãƒ£ãƒªã‚¢ã‚’è¨ˆç®—
            carrierSpeed = (sunSpeed * Zs + ringSpeed * Zr) / (Zs + Zr);
          } else {
            // ã‚µãƒ³ãŒæœªè¨­å®š â†’ ã‚­ãƒ£ãƒªã‚¢ã‹ã‚‰é€†ç®—
            sunSpeed = (carrierSpeed * (Zs + Zr) - ringSpeed * Zr) / Zs;
          }
        } else if (lastChanged === "car") {
          // ã‚­ãƒ£ãƒªã‚¢ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
          if (Math.abs(sunSpeed) > 0.01) {
            // ã‚µãƒ³ãŒè¨­å®šæ¸ˆã¿ â†’ ãƒªãƒ³ã‚°ã‚’è¨ˆç®—
            ringSpeed = (carrierSpeed * (Zs + Zr) - sunSpeed * Zs) / Zr;
          } else if (Math.abs(ringSpeed) > 0.01) {
            // ãƒªãƒ³ã‚°ãŒè¨­å®šæ¸ˆã¿ â†’ ã‚µãƒ³ã‚’è¨ˆç®—
            sunSpeed = (carrierSpeed * (Zs + Zr) - ringSpeed * Zr) / Zs;
          } else {
            // ä¸¡æ–¹æœªè¨­å®š â†’ ç›´çµã¨ã—ã¦è¨­å®š
            ringSpeed = carrierSpeed;
            sunSpeed = carrierSpeed;
          }
        }
      }

      // ãƒ‡ãƒãƒƒã‚°: è¨ˆç®—çµæœã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
      console.log(`[solveKinematics] âœ“ Sun: ${sunSpeed.toFixed(2)} RPM, Ring: ${ringSpeed.toFixed(2)} RPM, Carrier: ${carrierSpeed.toFixed(2)} RPM`);
    }

    function calculatePlanetSelfRotation() {
      // ãƒ—ãƒ©ãƒãƒƒãƒˆã®è‡ªè»¢é€Ÿåº¦ï¼ˆã‚­ãƒ£ãƒªã‚¢åŸºæº–ï¼‰
      // Ï‰p_self = -(Zs / Zp) Â· (Ï‰s - Ï‰c)
      return -(Zs / Zp) * (sunSpeed - carrierSpeed);
    }

    // ============================================================
    // UIæ›´æ–°
    // ============================================================
    function updateUI() {
      sunSlider.value = sunSpeed;
      ringSlider.value = ringSpeed;
      carSlider.value = carrierSpeed;
      
      sunTxt.textContent = sunSpeed.toFixed(1);
      ringTxt.textContent = ringSpeed.toFixed(1);
      carTxt.textContent = carrierSpeed.toFixed(1);
      
      statSun.textContent = sunSpeed.toFixed(1) + " RPM";
      statRing.textContent = ringSpeed.toFixed(1) + " RPM";
      statCar.textContent = carrierSpeed.toFixed(1) + " RPM";
      statPlanet.textContent = calculatePlanetSelfRotation().toFixed(1) + " RPM";
      
      // æ¸›é€Ÿæ¯”è¨ˆç®—ï¼ˆå…¥åŠ›/å‡ºåŠ›ï¼‰
      const epsilon = 0.1;
      
      // ã©ã‚ŒãŒå…¥åŠ›ã§ã©ã‚ŒãŒå‡ºåŠ›ã‹ã‚’åˆ¤å®š
      let inputSpeed = 0;
      let outputSpeed = 0;
      
      if (ringLocked) {
        // æ¸›é€Ÿãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ³å…¥åŠ› â†’ ã‚­ãƒ£ãƒªã‚¢å‡ºåŠ›
        inputSpeed = Math.abs(sunSpeed);
        outputSpeed = Math.abs(carrierSpeed);
      } else if (sunLocked) {
        // å¢—é€Ÿãƒ¢ãƒ¼ãƒ‰: ãƒªãƒ³ã‚°å…¥åŠ› â†’ ã‚­ãƒ£ãƒªã‚¢å‡ºåŠ›
        inputSpeed = Math.abs(ringSpeed);
        outputSpeed = Math.abs(carrierSpeed);
      } else if (carrierLocked) {
        // é€†è»¢ãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ³å…¥åŠ› â†’ ãƒªãƒ³ã‚°å‡ºåŠ›
        inputSpeed = Math.abs(sunSpeed);
        outputSpeed = Math.abs(ringSpeed);
      } else {
        // ç›´çµãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ³ã¨ãƒªãƒ³ã‚°ãŒå…¥åŠ›ã€ã‚­ãƒ£ãƒªã‚¢ãŒå‡ºåŠ›
        inputSpeed = Math.abs(sunSpeed);
        outputSpeed = Math.abs(carrierSpeed);
      }
      
      if (outputSpeed > epsilon && inputSpeed > epsilon) {
        const ratio = inputSpeed / outputSpeed;
        statRatio.textContent = ratio.toFixed(2) + ":1";
        statTorque.textContent = ratio.toFixed(2) + "x";
      } else {
        statRatio.textContent = "-";
        statTorque.textContent = "-";
      }
      
      // Williså¼æ¤œè¨¼
      const lhs = sunSpeed * Zs + ringSpeed * Zr;
      const rhs = carrierSpeed * (Zs + Zr);
      const error = Math.abs(lhs - rhs);

      if (error < 0.1) {
        willisCheck.innerHTML = "âœ“ æˆç«‹ (èª¤å·®: " + error.toFixed(3) + ")";
        willisCheck.style.color = "#4af2a1";
      } else {
        willisCheck.innerHTML = "âœ— ä¸æˆç«‹ (èª¤å·®: " + error.toFixed(3) + ")";
        willisCheck.style.color = "#f5576c";
      }

      // ãƒ‡ãƒãƒƒã‚°: UIæ›´æ–°å¾Œã®å€¤ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
      console.log(`[updateUI] è¡¨ç¤ºå€¤ - Sun: ${sunSpeed.toFixed(2)} RPM, Ring: ${ringSpeed.toFixed(2)} RPM, Carrier: ${carrierSpeed.toFixed(2)} RPM`);
      console.log(`[updateUI] Williså¼æ¤œè¨¼ - LHS: ${lhs.toFixed(2)}, RHS: ${rhs.toFixed(2)}, èª¤å·®: ${error.toFixed(3)}`);
    }

    function recalculate() {
      solveKinematics();
      updateUI();
      
      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’å¼·åˆ¶çš„ã«æ›´æ–°ï¼ˆãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
      if (!sunLocked) {
        sunSlider.value = sunSpeed;
      }
      if (!ringLocked) {
        ringSlider.value = ringSpeed;
      }
      if (!carrierLocked) {
        carSlider.value = carrierSpeed;
      }
    }

    // ============================================================
    // ãƒ¢ãƒ¼ãƒ‰è¨­å®š
    // ============================================================
    window.setMode = function(mode) {
      // å…¨ã¦ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
      sunLocked = ringLocked = carrierLocked = false;
      sunLock.checked = ringLock.checked = carLock.checked = false;
      sunSlider.disabled = ringSlider.disabled = carSlider.disabled = false;

      // è§’åº¦ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿æ™‚ã®æ®‹ç•™ã‚’é˜²æ­¢ï¼‰
      sunAngle = 0;
      ringAngle = 0;
      carrierAngle = 0;
      frameCount = 0;
      isFirstFrame = true;

      console.log(`[setMode] ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿: ${mode} - è§’åº¦ã¨ã‚«ã‚¦ãƒ³ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ`);

      switch (mode) {
        case 'reduction':
          // æ¸›é€Ÿãƒ¢ãƒ¼ãƒ‰: ãƒªãƒ³ã‚°å›ºå®šã€ã‚µãƒ³å…¥åŠ› â†’ ã‚­ãƒ£ãƒªã‚¢å‡ºåŠ›
          // ç†è«–å€¤: Ï‰s=60, Ï‰r=0 â†’ Ï‰c=15
          modeBadge.textContent = "æ¸›é€Ÿãƒ¢ãƒ¼ãƒ‰";
          modeBadge.style.background = "linear-gradient(135deg,#f093fb 0%,#f5576c 100%)";
          modeBadge.style.color = "#fff";
          sunSpeed = 60;
          ringSpeed = 0;
          carrierSpeed = 0;  // recalculate()ã§è¨ˆç®—ã•ã‚Œã‚‹
          ringLocked = true;
          ringLock.checked = true;
          ringSlider.disabled = true;
          lastChanged = "sun";
          break;

        case 'increase':
          // å¢—é€Ÿãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ³å›ºå®šã€ãƒªãƒ³ã‚°å…¥åŠ› â†’ ã‚­ãƒ£ãƒªã‚¢å‡ºåŠ›
          // ç†è«–å€¤: Ï‰s=0, Ï‰r=60 â†’ Ï‰c=45
          modeBadge.textContent = "å¢—é€Ÿãƒ¢ãƒ¼ãƒ‰";
          modeBadge.style.background = "linear-gradient(135deg,#4facfe 0%,#00f2fe 100%)";
          modeBadge.style.color = "#fff";
          sunSpeed = 0;
          ringSpeed = 60;
          carrierSpeed = 0;  // recalculate()ã§è¨ˆç®—ã•ã‚Œã‚‹
          sunLocked = true;
          sunLock.checked = true;
          sunSlider.disabled = true;
          lastChanged = "ring";
          break;

        case 'direct':
          // ç›´çµãƒ¢ãƒ¼ãƒ‰: å…¨ã¦åŒé€Ÿåº¦ã§å›è»¢
          // ç†è«–å€¤: Ï‰s=Ï‰r=Ï‰c=60
          modeBadge.textContent = "ç›´çµãƒ¢ãƒ¼ãƒ‰";
          modeBadge.style.background = "linear-gradient(135deg,#ffd700 0%,#ffed4e 100%)";
          modeBadge.style.color = "#333";
          sunSpeed = 60;
          ringSpeed = 60;
          carrierSpeed = 60;  // ç›´çµã§ã¯å…¨ã¦åŒã˜é€Ÿåº¦
          lastChanged = "sun";
          console.log(`[setMode] ç›´çµãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ–: Sun=${sunSpeed}, Ring=${ringSpeed}, Carrier=${carrierSpeed}`);
          break;

        case 'reverse':
          // é€†è»¢ãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ³å›ºå®šã€ã‚­ãƒ£ãƒªã‚¢å…¥åŠ› â†’ ãƒªãƒ³ã‚°å‡ºåŠ›ï¼ˆé€†å›è»¢ï¼‰
          // ç†è«–å€¤: Ï‰s=0, Ï‰c=60 â†’ Ï‰r=80
          modeBadge.textContent = "é€†è»¢ãƒ¢ãƒ¼ãƒ‰";
          modeBadge.style.background = "linear-gradient(135deg,#667eea 0%,#764ba2 100%)";
          modeBadge.style.color = "#fff";
          sunSpeed = 0;
          ringSpeed = 0;  // recalculate()ã§è¨ˆç®—ã•ã‚Œã‚‹
          carrierSpeed = 60;
          sunLocked = true;
          sunLock.checked = true;
          sunSlider.disabled = true;
          lastChanged = "car";
          break;
      }

      recalculate();
    }

    // ============================================================
    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    // ============================================================
    window.toggleAnim = function() {
      running = !running;
      toggleBtn.textContent = running ? "â¸ï¸ åœæ­¢" : "â–¶ï¸ å†ç”Ÿ";
    }

    window.resetView = function() {
      camera.position.set(6, 4, 8);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    sunSlider.addEventListener("input", e => {
      if (sunLocked) return;
      lastChanged = "sun";
      sunSpeed = parseFloat(e.target.value);
      recalculate();
    });

    ringSlider.addEventListener("input", e => {
      if (ringLocked) return;
      lastChanged = "ring";
      ringSpeed = parseFloat(e.target.value);
      recalculate();
    });

    carSlider.addEventListener("input", e => {
      if (carrierLocked) return;
      lastChanged = "car";
      carrierSpeed = parseFloat(e.target.value);
      recalculate();
    });

    sunLock.addEventListener("change", e => {
      sunLocked = e.target.checked;
      sunSlider.disabled = sunLocked;
      if (sunLocked) sunSpeed = 0;
      recalculate();
    });

    ringLock.addEventListener("change", e => {
      ringLocked = e.target.checked;
      ringSlider.disabled = ringLocked;
      if (ringLocked) ringSpeed = 0;
      recalculate();
    });

    carLock.addEventListener("change", e => {
      carrierLocked = e.target.checked;
      carSlider.disabled = carrierLocked;
      if (carrierLocked) carrierSpeed = 0;
      recalculate();
    });

    showWireframe.addEventListener("change", e => {
      wireframeObjects.forEach(w => w.visible = e.target.checked);
    });

    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼å¼·åº¦èª¿æ•´
    blurSlider.addEventListener("input", e => {
      const value = parseFloat(e.target.value);
      blurTxt.textContent = value + "%";
      if (afterimagePass) {
        afterimagePass.uniforms["damp"].value = value / 100;
      }
    });

    // ============================================================
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆé«˜åº¦ãªå®‰å®šåŒ– + ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼å¯¾å¿œï¼‰
    // ============================================================
    let frameCount = 0;
    let fpsHistory = [];
    let lastFpsReport = 0;
    let dtHistory = []; // dtå±¥æ­´ã§å¹³æ»‘åŒ–

    function animate() {
      requestAnimationFrame(animate);

      if (running) {
        const currentTime = performance.now();
        let dt = 1 / 60;

        // åˆå›ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†
        if (isFirstFrame) {
          lastTime = currentTime;
          isFirstFrame = false;
          dt = 1 / 60;
          dtHistory = [];
          console.log(`[animate] åˆå›ãƒ•ãƒ¬ãƒ¼ãƒ  - lastTimeåˆæœŸåŒ–: ${lastTime.toFixed(2)}ms`);
        } else {
          // é€šå¸¸ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†
          const rawDt = (currentTime - lastTime) / 1000;
          lastTime = currentTime;

          // FPSè¨ˆç®—ï¼ˆ1ç§’ã”ã¨ã«å¹³å‡FPSã‚’å ±å‘Šï¼‰
          const fps = rawDt > 0 ? 1 / rawDt : 60;
          fpsHistory.push(fps);

          if (currentTime - lastFpsReport > 1000) {
            const avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
            if (avgFps < 55) {
              console.warn(`[FPS] ä½FPSæ¤œå‡º: ${avgFps.toFixed(1)} FPSï¼ˆç›®æ¨™: 60 FPSï¼‰`);
            }
            fpsHistory = [];
            lastFpsReport = currentTime;
          }

          // dt ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ0.001ç§’ã€œ0.05ç§’ã®ç¯„å›²ï¼‰- ã‚ˆã‚Šå³æ ¼ãªç¯„å›²
          if (rawDt > 0 && rawDt < 0.05 && isFinite(rawDt)) {
            dtHistory.push(rawDt);
            // éå»3ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç§»å‹•å¹³å‡ã§å¹³æ»‘åŒ–ï¼ˆæŒ¯å‹•è»½æ¸›ï¼‰
            if (dtHistory.length > 3) dtHistory.shift();
            dt = dtHistory.reduce((a, b) => a + b, 0) / dtHistory.length;
          } else {
            console.warn(`[animate] Frame ${frameCount}: ç•°å¸¸ãªdtæ¤œå‡º ${(rawDt * 1000).toFixed(2)}ms â†’ 16.67ms(60FPS)ã«è£œæ­£`);
            dt = 1 / 60;
            dtHistory = []; // ç•°å¸¸æ¤œå‡ºæ™‚ã¯å±¥æ­´ã‚¯ãƒªã‚¢
          }
        }

        // RPMã‹ã‚‰ãƒ©ã‚¸ã‚¢ãƒ³/ç§’ã«å¤‰æ›: RPM * (2Ï€ / 60) = rad/s
        const rpm2rad = (2 * Math.PI) / 60;

        // è§’åº¦ã®å¤‰åŒ–é‡ã‚’è¨ˆç®—
        const sunDelta = sunSpeed * rpm2rad * dt;
        const ringDelta = ringSpeed * rpm2rad * dt;
        const carrierDelta = carrierSpeed * rpm2rad * dt;

        // è§’åº¦ã‚’æ›´æ–°ï¼ˆç©åˆ†ï¼‰
        sunAngle += sunDelta;
        ringAngle += ringDelta;
        carrierAngle += carrierDelta;

        // ãƒ‡ãƒãƒƒã‚°: 100ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ãƒªãƒ³ã‚°ã‚®ãƒ¤ã®çŠ¶æ…‹ã‚’å‡ºåŠ›
        if (frameCount % 100 === 0) {
          console.log(`[Frame ${frameCount}] Ring - Speed: ${ringSpeed.toFixed(2)} RPM, Delta: ${(ringDelta * 180 / Math.PI).toFixed(4)}Â°, Angle: ${(ringAngle * 180 / Math.PI).toFixed(2)}Â°, dt: ${(dt * 1000).toFixed(2)}ms`);
        }

        // ãƒ¡ãƒƒã‚·ãƒ¥ã«å›è»¢ã‚’é©ç”¨
        if (sunMesh) {
          sunMesh.rotation.y = sunAngle;
        }
        if (ringMesh) {
          ringMesh.rotation.y = ringAngle;
        }
        if (carrierGroup) {
          carrierGroup.rotation.y = carrierAngle;
        }

        // ãƒ—ãƒ©ãƒãƒƒãƒˆã‚®ãƒ¤ã®è‡ªè»¢ï¼ˆå®Œå…¨å™›ã¿åˆã„æ¡ä»¶ï¼‰
        // Ï‰p_self = -(Zs / Zp) Â· (Ï‰s - Ï‰c)
        // è§’åº¦ã§ã®è¡¨ç¾: Î¸p_self = -(Zs / Zp) Â· (Î¸s - Î¸c)
        const planetSelfRotation = -(Zs / Zp) * (sunAngle - carrierAngle);
        planetMeshes.forEach((planet, i) => {
          const phaseOffset = (i / numPlanets) * 2 * Math.PI;
          planet.rotation.y = planetSelfRotation - phaseOffset * (Zs / Zp);
        });

        frameCount++;
      } else {
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ä¸­ã¯åˆå›ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆã—ã¦ã€å†é–‹æ™‚ã«æ­£ã—ãåˆæœŸåŒ–
        isFirstFrame = true;
        frameCount = 0;
      }

      // è¡¨ç¤ºåˆ¶å¾¡
      axesHelper.visible = showAxes.checked;
      carrierArms.forEach(obj => obj.visible = showCarrier.checked);

      // è‡ªå‹•å›è»¢
      if (autoRotate.checked) {
        const t = Date.now() * 0.0002;
        const radius = 10;
        camera.position.x = Math.cos(t) * radius;
        camera.position.z = Math.sin(t) * radius;
        camera.position.y = 4 + Math.sin(t * 0.5) * 2;
        camera.lookAt(0, 0, 0);
      }

      controls.update();
      composer.render(); // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ–ãƒ©ãƒ¼ä»˜ããƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    }

    // ============================================================
    // åˆæœŸåŒ–ãƒ»é–‹å§‹
    // ============================================================
    initScene();
    setMode('reduction');
    animate();
  </script>

</body>
</html>
